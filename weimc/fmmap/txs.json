<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>weimc - FM transmitter maps (updated)</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
  <style>
    html, body { height: 100%; margin: 0; padding: 0; font-family: Arial, sans-serif; }
    #top-panel { position: absolute; top: 0; left: 0; right: 0; height: 50px; background: #333; display: flex; align-items: center; padding: 5px; z-index: 1000; }
    #top-panel button, #top-panel input { margin-right: 8px; height: 30px; font-family: Arial, sans-serif; }
    #map { position: absolute; top: 50px; bottom: 0; width: 100%; }
    #tx-sheet { position: absolute; top: 50px; left: 10px; width: 300px; background: #fff; padding: 10px; box-shadow: 0 0 5px rgba(0,0,0,0.5); z-index: 1001; display: none; max-height: 80%; overflow-y: auto; font-family: Arial, sans-serif; }
    .tooltip-box { position: absolute; pointer-events: none; background: rgba(255,255,255,0.95); padding: 5px; border: 1px solid #666; font-size: 12px; z-index: 2000; white-space: nowrap; font-family: Arial, sans-serif; transition: color 0.12s, font-weight 0.12s, opacity 0.12s; opacity: 0; box-shadow: 0 1px 4px rgba(0,0,0,0.12); border-radius: 3px; }
    table { width: 100%; border-collapse: collapse; margin-bottom: 5px; font-family: Arial, sans-serif; }
    th, td { border: 1px solid #ccc; padding: 4px; font-size: 12px; }
    button.small { padding: 2px 5px; font-size: 12px; }
    .freq-btn { background: none; border: none; text-decoration: underline; cursor: pointer; padding: 0; color: #0645ad; font-family: inherit; }
    .freq-btn.active { background: rgba(6,69,173,0.08); border-radius: 3px; }
  </style>
</head>
<body>
  <div id="top-panel">
    <button id="load-db">Load DB</button>
    <button id="save-db">Save DB</button>
    <button id="add-tx">Add TX</button>
    <input type="text" id="freq-filter" placeholder="Filter frequency (e.g. 105.7)" />
    <input type="text" id="pi-filter" placeholder="Filter PI code (e.g. 8201)" />
    <input type="text" id="eirp-filter" placeholder="Min EIRP (kW)" />
    <button id="toggle-selected">Toggle Selected TXs</button>
  </div>
  <div id="tx-sheet"></div>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
  <script>
  window.onload = function () {
    const map = L.map('map', { crs: L.CRS.Simple, minZoom: -5, maxZoom: 2, zoomSnap: 0.1 });
    const imgUrl = 'http://i.soupco.net/u/QdGeot.png';
    const bounds = [[0,0],[15904,15968]];
    L.imageOverlay(imgUrl, bounds).addTo(map);
    map.fitBounds(bounds);

    const icons = {
      low:  L.icon({ iconUrl:'https://maps.fmdx.org/old/img/tx-lo.png', iconSize:[19,19], iconAnchor:[9.5,19] }),
      med:  L.icon({ iconUrl:'https://maps.fmdx.org/old/img/tx-med.png', iconSize:[23,23], iconAnchor:[11.5,23] }),
      high: L.icon({ iconUrl:'https://maps.fmdx.org/old/img/tx-hi.png', iconSize:[27,27], iconAnchor:[13.5,27] }),
      rx:   L.icon({ iconUrl:'https://maps.fmdx.org/old/img/rx.png',    iconSize:[34,26], iconAnchor:[17,26] })
    };

    const tooltipOffsets = { lo:  { x: 6,  y: 18 }, med: { x: 8,  y: 22 }, hi:  { x: 9,  y: 26 } };
    const tooltipNudge = { lo:  { x: 0,  y: -19 }, med: { x: 0,  y: -23 }, hi:  { x: 0,  y: -27 } };

    let txList = [], rx = null, addingTX = false, filterFreq = null, filterPI = null, filterEIRP = null, showSelected = false;
    const selected = new Set();

    function computeDistanceCRS(crs1, crs2) {
      const dx = crs2.x - crs1.x, dy = crs2.y - crs1.y;
      return (Math.sqrt(dx * dx + dy * dy) * 0.1).toFixed(1);
    }

    function computeAzimuthCRS(crs1, crs2) {
      let theta = Math.atan2(crs2.x - crs1.x, crs2.y - crs1.y) * 180 / Math.PI;
      return ((theta + 360) % 360).toFixed(0);
    }

    document.getElementById('save-db').onclick = () => {
      const saveable = txList.map(tx => ({ id: tx.id, name: tx.name, stations: tx.stations, point: tx.point, latlng: tx.latlng }));
      const blob = new Blob([JSON.stringify({txList: saveable})], {type: 'application/json'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'fm_tx_db.json';
      a.click();
    };

    async function loadDB(urlFallback) {
      try {
        const res = await fetch(urlFallback);
        const loaded = await res.json();
        loaded.txList.forEach(t => { if (t.point) createTX(t, true); });
      } catch {
        const inp = document.createElement('input'); inp.type='file'; inp.accept='application/json';
        inp.onchange = e => {
          const r = new FileReader();
          r.onload = () => JSON.parse(r.result).txList.forEach(t => { if (t.point) createTX(t, true); });
          r.readAsText(e.target.files[0]);
        };
        inp.click();
      }
    }

    document.getElementById('load-db').onclick = () => loadDB('https://raw.githubusercontent.com/frenchkiddo6969/weizkule.github.io/refs/heads/main/weimc/fmmap/txs.json');
    loadDB('https://raw.githubusercontent.com/frenchkiddo6969/weizkule.github.io/refs/heads/main/weimc/fmmap/txs.json');

    document.getElementById('add-tx').onclick = () => { addingTX = true; map.getContainer().style.cursor='crosshair'; };
    map.on('click', e => {
      if(!addingTX) return;
      const name = prompt('Site name:'); if(!name){addingTX=false;map.getContainer().style.cursor='';return;}
      createTX({id:Date.now(),name,stations:[],point:map.latLngToLayerPoint(e.latlng)});
      addingTX=false; map.getContainer().style.cursor='';
    });

    function createTX(data,load=false) {
      const latlng = data.latlng ? L.latLng(data.latlng[0], data.latlng[1]) : map.layerPointToLatLng(data.point);
      const crsPt = map.options.crs.project(latlng);
      const marker = L.marker(latlng,{icon:icons.low,draggable:true}).addTo(map);
      const tx = {...data, marker, line: null, crs: crsPt, latlng: [latlng.lat, latlng.lng], stationCircles: {}, iconType: 'lo' };

      if (tx.stations && tx.stations.length) {
        tx.stations.sort((a, b) => (Number(a.freq) || 0) - (Number(b.freq) || 0));
      }

      txList.push(tx); updateIcon(tx); attach(tx);
      if(load) marker.fire('add');
    }

    function attach(tx) {
      tx.marker.on('contextmenu', () => {
        if (tx.line) {
          map.removeLayer(tx.line);
          tx.line = null;
          selected.delete(tx.id);
        } else {
          drawTrail(tx);
          selected.add(tx.id);
        }
      });
      tx.marker.on('click', () => {
        sheet.style.display = sheet.style.display === 'block' ? 'none' : 'block';
        openSheet(tx);
      });
      tx.marker.on('dragend',()=>{ const ll=tx.marker.getLatLng(); tx.crs=map.options.crs.project(ll); if(tx.line) drawTrail(tx); updateCoverageForTX(tx); repositionTipIfNeeded(tx); });
      tx.marker.on('drag', ()=> repositionTipIfNeeded(tx));
      tx.marker.on('mouseover',()=>showTip(tx));
      tx.marker.on('mouseout',hideTip);
    }

    function drawTrail(tx) {
      if(!rx) return;
      if(tx.line) map.removeLayer(tx.line);
      tx.line = L.polyline([rx.getLatLng(),tx.marker.getLatLng()],{color:'red',weight:2,opacity:0.7}).addTo(map);
    }

    map.on('contextmenu',e=>{
      if(rx) return;
      rx = L.marker(e.latlng,{icon:icons.rx,draggable:true}).addTo(map);
      rx.crs = map.options.crs.project(e.latlng);
      const pt = map.latLngToLayerPoint(e.latlng);
      document.cookie = `rx_x=${pt.x};rx_y=${pt.y}`;
      rx.on('dragend',()=>{
        const ll=rx.getLatLng(); rx.crs=map.options.crs.project(ll);
        txList.forEach(t=> t.line && drawTrail(t));
      });
    });

    const sheet=document.getElementById('tx-sheet');

    function openSheet(tx){
      sheet.innerHTML = '';
      const h = document.createElement('h4'); h.textContent = tx.name; sheet.appendChild(h);

      const table = document.createElement('table');
      const hdr = table.insertRow();
      ['Freq','Pol','Name','PI','kW',''].forEach(t => { const th = document.createElement('th'); th.innerText = t; hdr.appendChild(th); });

      tx.stations.forEach((s, i) => {
        const r = table.insertRow();
        const freqCell = r.insertCell();
        const freqBtn = document.createElement('button');
        freqBtn.className = 'freq-btn';
        freqBtn.innerText = s.freq !== undefined ? String(s.freq) : '';
        freqBtn.onclick = () => { toggleCoverageForStation(tx, i, freqBtn); };
        if (tx.stationCircles[i]) freqBtn.classList.add('active');
        freqCell.appendChild(freqBtn);

        const polCell = r.insertCell(); polCell.innerText = s.pol || '';
        const nameCell = r.insertCell(); nameCell.innerText = s.name || '';
        const piCell = r.insertCell(); piCell.innerText = s.pi || '';
        const kwCell = r.insertCell(); kwCell.innerText = (s.kw !== undefined && s.kw !== null && !isNaN(s.kw)) ? (Number(s.kw).toFixed(3) + ' kW') : '';

        const ctlCell = r.insertCell();
        const e = document.createElement('button'); e.innerText = 'âœŽ'; e.className='small';
        e.onclick = () => { editStation(tx, i); };
        const d = document.createElement('button'); d.innerText='ðŸ—‘'; d.className='small';
        d.onclick = () => {
          if (tx.stationCircles[i]) {
            try { map.removeLayer(tx.stationCircles[i].layer); } catch(e) {}
            delete tx.stationCircles[i];
          }
          tx.stations.splice(i,1);
          openSheet(tx);
          updateIcon(tx);
        };
        ctlCell.append(e,d);
      });

      const add = document.createElement('button'); add.innerText='Add station'; add.onclick=()=>addStation(tx);
      const del = document.createElement('button'); del.innerText='Delete TX'; del.style.marginLeft='10px';
      del.onclick = () => { map.removeLayer(tx.marker); if(tx.line) map.removeLayer(tx.line); Object.values(tx.stationCircles||{}).forEach(c => { try{ map.removeLayer(c.layer); }catch{} }); txList = txList.filter(t => t.id !== tx.id); sheet.style.display='none'; };
      sheet.append(table, add, del);
    }

    function addStation(tx){
      const f=parseFloat(prompt('Freq(87.5-108):'));
      if(isNaN(f)||f<87.5||f>108)return;
      const p=prompt('Pol(H,V,C,M,?):');
      const n=prompt('Name:');
      const pi=prompt('PI:');
      const kwInput=prompt('kW:');
      const kw=parseFloat(kwInput);

      // directional prompt (Y/N)
      const dirFlag = (prompt('Make this station directional? (Y/N)') || '').trim().toUpperCase();
      let directional = false, directionAngle = null;
      if (dirFlag === 'Y' || dirFlag === 'YES') {
        directional = true;
        const angleInput = prompt('Direction angle (0-359, 0 = North, clockwise):', '0');
        const angleNum = parseInt(angleInput, 10);
        if (!isNaN(angleNum) && angleNum >= 0 && angleNum <= 359) directionAngle = angleNum;
        else { directional = false; directionAngle = null; }
      }

      tx.stations.push({freq:f,pol:p,name:n,pi:pi,kw:kw, directional: directional, directionAngle: directionAngle});

      if (tx.stations && tx.stations.length) {
        tx.stations.sort((a, b) => (Number(a.freq) || 0) - (Number(b.freq) || 0));
      }

      openSheet(tx);
      updateIcon(tx);
    }

    function editStation(tx,i){
      const s=tx.stations[i];
      const f=parseFloat(prompt('Freq:',s.freq));
      if(isNaN(f)||f<87.5||f>108)return;
      s.freq=f;
      s.pol=prompt('Pol:',s.pol);
      s.name=prompt('Name:',s.name);
      s.pi=prompt('PI:',s.pi);
      const kwInput = prompt('kW:', s.kw);
      s.kw = parseFloat(kwInput);

      const dirFlag = (prompt('Make this station directional? (Y/N)', s.directional ? 'Y' : 'N') || '').trim().toUpperCase();
      if (dirFlag === 'Y' || dirFlag === 'YES') {
        s.directional = true;
        const angleInput = prompt('Direction angle (0-359, 0 = North, clockwise):', (typeof s.directionAngle === 'number' && !isNaN(s.directionAngle)) ? String(s.directionAngle) : '0');
        const angleNum = parseInt(angleInput, 10);
        if (!isNaN(angleNum) && angleNum >= 0 && angleNum <= 359) s.directionAngle = angleNum; else { s.directional = false; s.directionAngle = null; }
      } else {
        s.directional = false;
        s.directionAngle = null;
      }

      if (tx.stations && tx.stations.length) {
        tx.stations.sort((a, b) => (Number(a.freq) || 0) - (Number(b.freq) || 0));
      }

      openSheet(tx);
      updateIcon(tx);
    }

    function updateIcon(tx){
      let m = 0;
      const filteredStations = tx.stations.filter(s => {
        const freqMatch = !filterFreq || s.freq === filterFreq;
        const piMatch = !filterPI || (s.pi && s.pi.toUpperCase() === filterPI);
        const eirpMatch = !filterEIRP || (s.kw || 0) >= filterEIRP;
        return freqMatch && piMatch && eirpMatch;
      });
      if (filteredStations.length) m = Math.max(...filteredStations.map(s => s.kw || 0));
      else if (!filterFreq && !filterPI && !filterEIRP && tx.stations.length) m = Math.max(...tx.stations.map(s => s.kw || 0));

      if (m >= 5) { tx.marker.setIcon(icons.high); tx.iconType = 'hi'; }
      else if (m >= 0.5) { tx.marker.setIcon(icons.med); tx.iconType = 'med'; }
      else { tx.marker.setIcon(icons.low); tx.iconType = 'lo'; }
    }

    const tip = document.createElement('div');
    tip.className = 'tooltip-box';
    document.body.append(tip);
    let hoveredTx = null;

    function positionTipForTx(tx) {
      if (!tx) return;
      if (!rx) return;

      const crsRx = rx.crs || map.options.crs.project(rx.getLatLng());
      const crsTx = tx.crs || map.options.crs.project(tx.marker.getLatLng());
      const dx = crsRx.x - crsTx.x, dy = crsRx.y - crsTx.y;
      const distKm = Math.sqrt(dx*dx + dy*dy) * 0.1;
      const distKmRounded = Math.round(distKm);
      // azimuth: compute bearing from TX -> RX (0 = north, clockwise)
      const az = computeAzimuthCRS(crsTx, crsRx);

      tip.innerHTML = '';
      const nameNode = document.createTextNode(tx.name + ' â€“ ');
      const kmSpan = document.createElement('span');
      kmSpan.textContent = distKmRounded + ' km';
      if (distKmRounded >= 700) { kmSpan.style.color = 'red'; kmSpan.style.fontWeight = 'bold'; }
      else if (distKmRounded >= 400) { kmSpan.style.color = 'black'; kmSpan.style.fontWeight = 'bold'; }
      else { kmSpan.style.color = 'black'; kmSpan.style.fontWeight = 'normal'; }
      const restNode = document.createTextNode(' â€“ ' + az + 'Â°');
      tip.appendChild(nameNode);
      tip.appendChild(kmSpan);
      tip.appendChild(restNode);

      let clientX, clientY;
      const iconEl = (tx.marker && tx.marker.getElement) ? tx.marker.getElement() : null;

      if (iconEl && iconEl.getBoundingClientRect) {
        const rect = iconEl.getBoundingClientRect();
        clientX = rect.left;
        clientY = rect.top + rect.height;
      } else {
        const pos = map.latLngToContainerPoint(tx.marker.getLatLng());
        const containerRect = map.getContainer().getBoundingClientRect();
        clientX = containerRect.left + pos.x;
        clientY = containerRect.top + pos.y;
      }

      const iconType = tx.iconType || 'lo';
      const offset = tooltipOffsets[iconType] || {x:0,y:0};
      const nudge  = tooltipNudge[iconType]  || {x:0,y:0};

      tip.style.visibility = 'hidden';
      tip.style.display = 'block';
      const left = Math.round(clientX + offset.x + nudge.x);
      const top  = Math.round(clientY + offset.y + nudge.y);
      tip.style.left = left + 'px';
      tip.style.top  = top + 'px';
      tip.style.visibility = 'visible';
      tip.style.opacity = '1';
    }

    function showTip(tx) { hoveredTx = tx; if (!rx) return; positionTipForTx(tx); }
    function hideTip() { hoveredTx = null; tip.style.display = 'none'; tip.style.opacity = '0'; }
    function repositionTipIfNeeded(tx) { if (hoveredTx && tx && hoveredTx.id === tx.id) positionTipForTx(tx); }
    map.on('move zoom', () => { if (hoveredTx) positionTipForTx(hoveredTx); });

    function applyFilters() {
      txList.forEach(tx => {
        const matchesFreq = !filterFreq || tx.stations.some(s => s.freq === filterFreq);
        const matchesPI = !filterPI || tx.stations.some(s => s.pi && s.pi.toUpperCase() === filterPI);
        const matchesEIRP = !filterEIRP || tx.stations.some(s => (s.kw || 0) >= filterEIRP);
        const shouldShow = matchesFreq && matchesPI && matchesEIRP;
        if (shouldShow) {
          if (!map.hasLayer(tx.marker)) map.addLayer(tx.marker);
        } else {
          if (map.hasLayer(tx.marker)) map.removeLayer(tx.marker);
        }
        updateIcon(tx);
      });
    }

    document.getElementById('freq-filter').oninput = e => { filterFreq = parseFloat(e.target.value) || null; applyFilters(); };
    document.getElementById('pi-filter').oninput = e => { const input = e.target.value.trim().toUpperCase(); filterPI = input.length ? input : null; applyFilters(); };
    document.getElementById('eirp-filter').oninput = e => { filterEIRP = parseFloat(e.target.value) || null; applyFilters(); };

    document.getElementById('toggle-selected').onclick=()=>{ showSelected=!showSelected; txList.forEach(tx=>{ if(showSelected&&!selected.has(tx.id))map.removeLayer(tx.marker); else if(!map.hasLayer(tx.marker))map.addLayer(tx.marker); }); };

    /********* Coverage polygon logic (seeded, slightly uneven, directional support) *********/

    // seeded PRNG (mulberry32)
    function seedFromString(str) {
      let h = 2166136261 >>> 0;
      for (let i = 0; i < str.length; i++) h = Math.imul(h ^ str.charCodeAt(i), 16777619) >>> 0;
      return h;
    }
    function mulberry32(a) {
      return function() {
        a |= 0; a = (a + 0x6D2B79F5) | 0;
        let t = Math.imul(a ^ a >>> 15, 1 | a);
        t = (t + Math.imul(t ^ t >>> 7, 61 | t)) ^ t;
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }

    function degToRad(d){ return d * Math.PI/180; }

    // map direction string to angle (0 = north, clockwise)
    const dirToAngle = { 'N':0, 'NE':45, 'E':90, 'SE':135, 'S':180, 'SW':225, 'W':270, 'NW':315 };

    // slightly uneven polygon generator: per-TX+radius seed -> deterministic slight noise
    function createCoveragePolygon(centerLatLng, radiusKm, tx, stationIndex, directional=false, directionAngle=null, segments = 64) {
      if (!radiusKm || radiusKm <= 0) return L.polygon([], {color:'blue', weight:2, opacity:0.6, fillOpacity:0.08});

      // seed depends on TX id and quantized radius so same TX/EIRP produce same shape
      const quant = Math.round(radiusKm * 10); // 0.1 km quant
      const seedStr = `${tx.id}_${quant}`;
      const rnd = mulberry32(seedFromString(seedStr));

      const centerCRS = map.options.crs.project(centerLatLng);
      const latlngs = [];

      const R = radiusKm;
      // directionAngle: degrees, 0 = north, clockwise. If provided, use it.
      let dirAngle = null;
        if (typeof directionAngle === 'number' && !isNaN(directionAngle)) {
          dirAngle = ((directionAngle % 360) + 360) % 360;
        }

      for (let i = 0; i < segments; i++) {
        // a: radians where 0 = east, ccw positive
        const a = (i / segments) * Math.PI * 2;
        // convert to compass degrees where 0 = north, clockwise
        const angleDeg = (90 - (a * 180 / Math.PI) + 360) % 360;

        // base radius
        let baseRadius = R;

        // polarization-specific shape modulation
        // determine station polarization if available
        let pol = null;
        try { const s = tx.stations && tx.stations[stationIndex]; if (s && s.pol) pol = String(s.pol).toUpperCase(); } catch (e) { pol = null; }

        if (pol === 'C' || pol === 'O') {
          // C = circular: keep baseRadius (with slight per-vertex perturbation applied below)
          baseRadius = R;
        } else if (pol === 'H') {
          // H = horizontal: smooth 6-point star (low-contrast)
          // use a gentle 6-fold cosine modulation to push radius toward edges
          const theta = a; // radians
          const starFactor = 1 + 0.12 * Math.cos(6 * theta); // vary Â±12%
          baseRadius = R * starFactor;
        } else if (pol === 'V') {
          // V = vertical: create a 'sideways W' feeling at the back and a cropped half-circle at the front
          if (dirAngle === null) {
            // if no direction provided, treat front as 0 (north)
            // front half: angle difference to 0
            const delta = Math.min(Math.abs(((angleDeg - 0 + 540) % 360) - 180), 180);
            if (delta <= 90) {
              // front half: cropped (use ~90% radius)
              baseRadius = R * 0.9;
            } else {
              // back: W-like lobes using cos(4*theta) (four lobes -> W shape sideways)
              const theta = a;
              const wFactor = 1 + 0.18 * Math.cos(4 * theta); // Â±18%
              baseRadius = R * wFactor * 0.85; // slightly reduced overall
            }
          } else {
            // compute smallest angular difference between this vertex and the front direction
            const delta = Math.abs(((angleDeg - dirAngle + 540) % 360) - 180); // [0,180]
            if (delta <= 90) {
              // front half (within Â±90Â° of dirAngle) cropped
              baseRadius = R * 0.9;
            } else {
              // back half: create W-like lobes oriented perpendicular to the front direction
              // Achieve 'sideways W' by rotating the cosine frequency by 90Â° relative to front
              // shift angle by 90Â°: convert to radians
              const relRad = degToRad(angleDeg - dirAngle + 90);
              const wFactor = 1 + 0.18 * Math.cos(4 * relRad); // Â±18%
              baseRadius = R * wFactor * 0.85;
            }
          }
        } else {
          // default: slight variation from circular
          baseRadius = R;
        }

        // directional shaping if a numeric directionAngle is provided (smooth interpolation front/back)
        if (dirAngle !== null) {
          // compute angular difference where 0 -> front
          let delta = Math.abs(((angleDeg - dirAngle + 540) % 360) - 180); // [0,180]
          // t = 1 at front, 0 at back
          const t = (Math.cos(degToRad(delta)) + 1) / 2;
          // blend between front (baseRadius) and back reduced radius (approx 20 km min for large R)
          const backMin = 0.2 * R; // back radius is 20% of base radius (proportional to power)
          baseRadius = backMin + (baseRadius - backMin) * t;
        }

        // small per-vertex perturbation (Â±7%) to make shape slightly uneven
        const perturb = 1 + (rnd() - 0.5) * 0.14; // range roughly [0.93,1.07]
        const r = Math.max(0.1, baseRadius * perturb);

        // convert r (km) to CRS units (CRS in this map uses 0.1 km per unit)
        const dx = Math.cos(a) * r * 10; // km->CRS units
        const dy = Math.sin(a) * r * 10;
        const ptCRS = L.point(centerCRS.x + dx, centerCRS.y + dy);
        latlngs.push(map.options.crs.unproject(ptCRS));
      }

      return L.polygon(latlngs, { color: 'blue', weight: 2, opacity: 0.6, fillOpacity: 0.08 });
    }

    function kW_to_km_radius(kw) {
      const k = Number(kw) || 0;
      if (k <= 0) return 0;
      const log = Math.log10(k);
      const radius = -3 * (log * log) + 37.5 * log + 65;
      return Math.max(0, radius);
    }

    function toggleCoverageForStation(tx, stationIndex, freqBtnElement) {
      const s = tx.stations[stationIndex];
      if (!s) return;
      const kw = Number(s.kw) || 0;
      const radiusKm = kW_to_km_radius(kw);
      // remove existing
      if (tx.stationCircles && tx.stationCircles[stationIndex]) {
        try { map.removeLayer(tx.stationCircles[stationIndex].layer); } catch (e) {}
        delete tx.stationCircles[stationIndex];
        if (freqBtnElement) freqBtnElement.classList.remove('active');
        return;
      }

      // create polygon using TX-level seeded shape (same EIRP -> same shape), but allow directional modification per-station
      const poly = createCoveragePolygon(tx.marker.getLatLng(), radiusKm, tx, stationIndex, !!s.directional, s.directionAngle);
      poly.addTo(map);
      tx.stationCircles[stationIndex] = { layer: poly, km: radiusKm, centerLatLng: tx.marker.getLatLng(), directional: !!s.directional, directionAngle: s.directionAngle };
      if (freqBtnElement) freqBtnElement.classList.add('active');
    }

    function updateCoverageForTX(tx) {
      if (!tx.stationCircles) return;
      Object.keys(tx.stationCircles).forEach(idx => {
        const sc = tx.stationCircles[idx];
        if (!sc) return;
        try { map.removeLayer(sc.layer); } catch (e) {}
        // find station to get kw/direction
        const s = tx.stations[idx];
        const radiusKm = sc.km || (s ? kW_to_km_radius(s.kw) : 0);
        const poly = createCoveragePolygon(tx.marker.getLatLng(), radiusKm, tx, idx, !!(s && s.directional), s && s.directionAngle);
        poly.addTo(map);
        tx.stationCircles[idx] = { layer: poly, km: radiusKm, centerLatLng: tx.marker.getLatLng(), directional: !!(s && s.directional), directionAngle: s && s.directionAngle };
      });
    }

    function updateAllCoverage() { txList.forEach(tx => updateCoverageForTX(tx)); }
    map.on('zoomend', updateAllCoverage); map.on('moveend', updateAllCoverage);

    function removeAllCoverage() {
      txList.forEach(tx => {
        if (!tx.stationCircles) return;
        Object.values(tx.stationCircles).forEach(c => { try{ map.removeLayer(c.layer); } catch {} });
        tx.stationCircles = {};
      });
    }

    /********* End coverage logic *********/

  };
  </script>
</body>
</html>
