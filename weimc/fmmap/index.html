<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>weimc - FM transmitter maps</title>
  <link rel="icon" href="https://maps.fmdx.org/old/img/tx-med.png" type="image/png">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
  <style>
    html, body { height: 100%; margin: 0; padding: 0; font-family: Arial, sans-serif; }
    #top-panel { position: absolute; top: 0; left: 0; right: 0; height: 50px; background: #333; display: flex; align-items: center; padding: 6px; z-index: 1000; gap:8px; }
    #top-panel button, #top-panel input, #top-panel label { height: 30px; font-family: Arial, sans-serif; }
    #map { position: absolute; top: 50px; bottom: 0; width: 100%; }
    #tx-sheet { position: absolute; top: 50px; left: 10px; width: 330px; background: #fff; padding: 10px; box-shadow: 0 0 5px rgba(0,0,0,0.5); z-index: 1001; display: none; max-height: 80%; overflow-y: auto; }
    .tooltip-box { position: absolute; pointer-events: none; background: rgba(255,255,255,0.95); padding: 5px; border: 1px solid #666; font-size: 12px; z-index: 2000; white-space: nowrap; transition: color 0.12s, font-weight 0.12s, opacity 0.12s; opacity: 0; box-shadow: 0 1px 4px rgba(0,0,0,0.12); border-radius: 3px; }
    table { width: 100%; border-collapse: collapse; margin-bottom: 5px; }
    th, td { border: 1px solid #ccc; padding: 4px; font-size: 12px; }
    button.small { padding: 2px 5px; font-size: 12px; }

    /* freq button: inline with no space between freq and pol letter */
    .freq-btn { background: none; border: none; text-decoration: underline; cursor: pointer; padding: 0; color: #0645ad; font-family: inherit; display: inline-flex; align-items: baseline; gap: 0; }
    .freq-btn.active { background: rgba(6,69,173,0.08); border-radius: 3px; }

    /* visuals for sheet highlighting/dimming - no text color/bold changes */
    tr.dim { background: #f4f4f4; } /* grayed background only */
    tr.highlight { background: #fff7c2; } /* light yellow highlight only */
    .freq-btn.criteria { background: rgba(255,235,150,0.6); border-radius: 3px; } /* freq button when used as criterion */
    .station-name { cursor: pointer; color: #0645ad; text-decoration: underline; }

    /* frequency value and polarization letter styling: freq normal weight/size, pol smaller and lowercase with NO gap */
    .freq-btn .freq-val, .freq-btn .pol { font-size: inherit; font-weight: inherit; line-height: 1; }
    .freq-btn .pol { text-transform: lowercase; }

    /* compact control styles */
    .control-group { display:flex; align-items:center; gap:6px; color:#fff; }
    .control-group input[type='number'] { width:84px; padding:4px; }
    .control-group input[type='checkbox'] { transform:scale(1.1); }
    .control-actions button { padding:6px 8px; }

    /* hide the left-image resize controls */
    #left-image-controls { display: none !important; }
  </style>
</head>
<body>
  <div id="top-panel">
    <button id="load-db">Load DB</button>
    <button id="save-db">Save DB</button>
    <button id="add-tx">Add TX</button>

    <!-- LEFT IMAGE RESIZE CONTROLS (INJECTED) -->
    <div id="left-image-controls" class="control-group" style="margin-left:8px">
      <label style="color:#fff;">Left W:</label>
      <input id="left-width-input" type="number" step="1" min="1" value="1072" title="Width in CRS units" />
      <label style="color:#fff;">Left H:</label>
      <input id="left-height-input" type="number" step="1" min="1" value="2160" title="Height in CRS units (leave for auto or change)" />
      <label style="color:#fff;">V off:</label>
      <input id="left-voffset-input" type="number" step="1" value="6496" title="Vertical offset in CRS units" />
      <label style="color:#fff">Preserve aspect</label>
      <input id="left-preserve-check" type="checkbox" title="Preserve pixel aspect ratio when checked" />
      <div class="control-actions">
        <button id="left-apply-btn">Apply</button>
        <button id="left-center-btn">Center</button>
      </div>
    </div>

    <input type="text" id="freq-filter" placeholder="Filter frequency (e.g. 105.7)" />
    <input type="text" id="pi-filter" placeholder="Filter PI code (e.g. 8201)" />
    <input type="text" id="eirp-filter" placeholder="Min EIRP (kW)" />
    <input type="text" id="station-filter" placeholder="Filter station name (exact)" />
    <button id="toggle-selected">Toggle Selected TXs</button>
  </div>
  <div id="tx-sheet"></div>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
  <script>
  window.onload = function () {
    const map = L.map('map', { crs: L.CRS.Simple, minZoom: -5, maxZoom: 2, zoomSnap: 0.1 });

    // --- PANES ---
    if (!map.getPane('coveragePane')) map.createPane('coveragePane');
    map.getPane('coveragePane').style.zIndex = 450;
    map.getPane('coveragePane').style.pointerEvents = 'auto';

    if (!map.getPane('trailPane')) map.createPane('trailPane');
    map.getPane('trailPane').style.zIndex = 500;
    map.getPane('trailPane').style.pointerEvents = 'auto';

    // === CONFIG: where to place the extra left image ===
    const MAIN_WIDTH_UNITS = 15904;
    const MAIN_HEIGHT_UNITS = 15968;

    const mainImgUrl = 'https://i.soupco.net/raw/cqzOlj.png';
    const leftImgUrl = 'https://i.soupco.net/u/94axuV.png';

    const mainBounds = [[0, 0], [MAIN_WIDTH_UNITS, MAIN_HEIGHT_UNITS]];
    const mainOverlay = L.imageOverlay(mainImgUrl, mainBounds, { interactive: false, opacity: 1.0, zIndex: 500 }).addTo(map);

    map.fitBounds(mainBounds);

    let leftOverlay = null;
    let lastLeftHeightUnits = MAIN_WIDTH_UNITS;

    function removeLeftOverlay() {
      if (leftOverlay) {
        try { map.removeLayer(leftOverlay); } catch (e) {}
        leftOverlay = null;
      }
    }

    function leftBoundsFromParams(widthUnits, heightUnits, vOffsetUnits) {
      const leftSouthWest = [vOffsetUnits, -Math.abs(widthUnits)];
      const leftNorthEast = [vOffsetUnits + Math.abs(heightUnits), 0];
      return [leftSouthWest, leftNorthEast];
    }

    function addLeftOverlay({ widthUnits = 6000, heightUnits = null, vOffsetUnits = 0, preserveAspect = false } = {}) {
      removeLeftOverlay();

      const applyOverlay = (hUnits) => {
        lastLeftHeightUnits = hUnits;
        const bounds = leftBoundsFromParams(widthUnits, hUnits, vOffsetUnits);
        leftOverlay = L.imageOverlay(leftImgUrl, bounds, { interactive: false, opacity: 1.0, zIndex: 400 }).addTo(map);
      };

      if (preserveAspect) {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.src = leftImgUrl + (leftImgUrl.indexOf('?') === -1 ? '?_=' + Date.now() : '&_=' + Date.now());
        img.onload = function() {
          const imgW = img.naturalWidth || img.width;
          const imgH = img.naturalHeight || img.height || 1;
          const computedHUnits = Math.round(widthUnits * (imgH / imgW));
          applyOverlay(computedHUnits);
          document.getElementById('left-height-input').value = computedHUnits;
        };
        img.onerror = function() { applyOverlay(MAIN_WIDTH_UNITS); };
      } else {
        const h = (heightUnits === null || typeof heightUnits === 'undefined') ? MAIN_WIDTH_UNITS : Math.abs(heightUnits);
        applyOverlay(h);
      }
    }

    const widthInput = document.getElementById('left-width-input');
    const heightInput = document.getElementById('left-height-input');
    const voffsetInput = document.getElementById('left-voffset-input');
    const preserveCheck = document.getElementById('left-preserve-check');
    const applyBtn = document.getElementById('left-apply-btn');
    const centerBtn = document.getElementById('left-center-btn');

    const leftControlsEl = document.getElementById('left-image-controls');
    if (leftControlsEl) leftControlsEl.style.display = 'none';

    applyBtn.onclick = () => {
      const w = parseInt(widthInput.value, 10) || 6000;
      const h = parseInt(heightInput.value, 10);
      const vo = parseInt(voffsetInput.value, 10) || 0;
      const preserve = preserveCheck.checked;
      addLeftOverlay({ widthUnits: w, heightUnits: h, vOffsetUnits: vo, preserveAspect: preserve });
    };

    centerBtn.onclick = () => {
      const w = parseInt(widthInput.value, 10) || 6000;
      const h = parseInt(heightInput.value, 10) || lastLeftHeightUnits || MAIN_WIDTH_UNITS;
      const vOffset = Math.round((MAIN_WIDTH_UNITS - h) / 2);
      voffsetInput.value = vOffset;
      addLeftOverlay({ widthUnits: w, heightUnits: h, vOffsetUnits: vOffset, preserveAspect: preserveCheck.checked });
    };

    widthInput.ondblclick = () => { widthInput.value = Math.round((parseInt(widthInput.value,10)||6000) * 2); applyBtn.click(); };
    widthInput.oncontextmenu = (e) => { e.preventDefault(); widthInput.value = Math.max(1, Math.round((parseInt(widthInput.value,10)||6000) / 2)); applyBtn.click(); };

    addLeftOverlay({ widthUnits: parseInt(widthInput.value,10)||6000, heightUnits: parseInt(heightInput.value,10) || MAIN_WIDTH_UNITS, vOffsetUnits: parseInt(voffsetInput.value,10)||0, preserveAspect: false });

    // --- ICONS (including selected variants) ---
    const icons = {
      low:  L.icon({ iconUrl:'https://maps.fmdx.org/old/img/tx-lo.png', iconSize:[19,19], iconAnchor:[9.5,19] }),
      med:  L.icon({ iconUrl:'https://maps.fmdx.org/old/img/tx-med.png', iconSize:[23,23], iconAnchor:[11.5,23] }),
      high: L.icon({ iconUrl:'https://maps.fmdx.org/old/img/tx-hi.png', iconSize:[27,27], iconAnchor:[13.5,27] }),
      lowSel:  L.icon({ iconUrl:'https://maps.fmdx.org/old/img/tx-lo-sel.png', iconSize:[19,19], iconAnchor:[9.5,19] }),
      medSel:  L.icon({ iconUrl:'https://maps.fmdx.org/old/img/tx-med-sel.png', iconSize:[23,23], iconAnchor:[11.5,23] }),
      highSel: L.icon({ iconUrl:'https://maps.fmdx.org/old/img/tx-hi-sel.png', iconSize:[27,27], iconAnchor:[13.5,27] }),
      rx:   L.icon({ iconUrl:'https://maps.fmdx.org/old/img/rx.png',    iconSize:[34,26], iconAnchor:[17,26] })
    };

    const tooltipOffsets = { lo:  { x: 6,  y: 18 }, med: { x: 8,  y: 22 }, hi:  { x: 9,  y: 26 } };
    const tooltipNudge = { lo:  { x: 3,  y: -19 }, med: { x: 4,  y: -23 }, hi:  { x: 5,  y: -27 } };

    let txList = [], rx = null, addingTX = false, filterFreq = null, filterPI = null, filterEIRP = null, filterStationName = null, showSelected = false;
    const selected = new Set();
    let currentOpenTx = null; // id of TX currently shown in sheet

    function computeDistanceCRS(crs1, crs2) {
      const dx = crs2.x - crs1.x, dy = crs2.y - crs1.y;
      return (Math.sqrt(dx * dx + dy * dy) * 0.1).toFixed(1);
    }

    function computeAzimuthCRS(crs1, crs2) {
      let theta = Math.atan2(crs2.x - crs1.x, crs2.y - crs1.y) * 180 / Math.PI;
      return ((theta + 360) % 360).toFixed(0);
    }

    function isDirectionalFlag(val) {
      if (val === true) return true;
      if (val === false || val === null || typeof val === 'undefined') return false;
      if (typeof val === 'number') return val === 1;
      if (typeof val === 'string') {
        const v = val.trim().toUpperCase();
        return (v === 'Y' || v === 'YES' || v === 'TRUE' || v === '1');
      }
      return false;
    }

    document.getElementById('save-db').onclick = () => {
      const saveable = txList.map(tx => ({ id: tx.id, name: tx.name, stations: tx.stations, point: tx.point, latlng: tx.latlng }));
      const blob = new Blob([JSON.stringify({txList: saveable})], {type: 'application/json'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'fm_tx_db.json';
      a.click();
    };

    async function loadDB(urlFallback) {
      try {
        const res = await fetch(urlFallback);
        const loaded = await res.json();
        loaded.txList.forEach(t => { if (t.point) createTX(t, true); });
      } catch {
        const inp = document.createElement('input'); inp.type='file'; inp.accept='application/json';
        inp.onchange = e => {
          const r = new FileReader();
          r.onload = () => JSON.parse(r.result).txList.forEach(t => { if (t.point) createTX(t, true); });
          r.readAsText(e.target.files[0]);
        };
        inp.click();
      }
    }

    document.getElementById('load-db').onclick = () => loadDB('https://raw.githubusercontent.com/frenchkiddo6969/weizkule.github.io/refs/heads/main/weimc/fmmap/txs.json');
    loadDB('https://raw.githubusercontent.com/frenchkiddo6969/weizkule.github.io/refs/heads/main/weimc/fmmap/txs.json');

    document.getElementById('add-tx').onclick = () => { addingTX = true; map.getContainer().style.cursor='crosshair'; };
    map.on('click', e => {
      if(!addingTX) return;
      const name = prompt('Site name:'); if(!name){addingTX=false;map.getContainer().style.cursor='';return;}
      createTX({id:Date.now(),name,stations:[],point:map.latLngToLayerPoint(e.latlng)});
      addingTX=false; map.getContainer().style.cursor='';
    });

    // helper to set selected visual state for a tx
    function setSelected(tx, isSelected) {
      if (!tx || !tx.marker) return;
      if (isSelected) selected.add(tx.id); else selected.delete(tx.id);

      const type = tx.iconType || 'lo';
      let iconToUse = icons.low;
      if (type === 'lo') iconToUse = isSelected ? icons.lowSel : icons.low;
      else if (type === 'med') iconToUse = isSelected ? icons.medSel : icons.med;
      else if (type === 'hi') iconToUse = isSelected ? icons.highSel : icons.high;
      try { tx.marker.setIcon(iconToUse); } catch (e) {}
    }

    function createTX(data,load=false) {
      if (data.stations && Array.isArray(data.stations)) {
        data.stations.forEach(s => {
          try {
            s.directional = isDirectionalFlag(s.directional);
            if (s.directionAngle !== undefined && s.directionAngle !== null) {
              const na = parseInt(s.directionAngle, 10);
              s.directionAngle = (!isNaN(na) && na >= 0 && na <= 359) ? na : null;
            } else {
              s.directionAngle = null;
            }
          } catch (e) {
            s.directional = false;
            s.directionAngle = null;
          }
        });
      }

      const latlng = data.latlng ? L.latLng(data.latlng[0], data.latlng[1]) : map.layerPointToLatLng(data.point);
      const crsPt = map.options.crs.project(latlng);
      const marker = L.marker(latlng,{draggable:true}).addTo(map);
      const tx = {...data, marker, line: null, crs: crsPt, latlng: [latlng.lat, latlng.lng], stationCircles: {}, iconType: 'lo', highlightCriteria: null };

      if (tx.stations && tx.stations.length) {
        tx.stations.sort((a, b) => (Number(a.freq) || 0) - (Number(b.freq) || 0));
      }

      txList.push(tx);
      updateIcon(tx);
      setSelected(tx, selected.has(tx.id));
      attach(tx);
      if(load) marker.fire('add');
    }

    function attach(tx) {
      tx.marker.on('contextmenu', () => {
        // Toggle trail but KEEP marker in normal (non-selected) icon state.
        if (tx.line) {
          try { map.removeLayer(tx.line); } catch (e) {}
          tx.line = null;
          // ensure normal (non-selected) icon after removing trail
          setSelected(tx, false);
        } else {
          drawTrail(tx);
          // ensure normal (non-selected) icon when trail is created
          setSelected(tx, false);
        }
      });

      // LEFT-CLICK handler: open/close sheet AND toggle selection appropriately
      tx.marker.on('click', () => {
        if (sheet.style.display === 'block' && currentOpenTx === tx.id) {
          // sheet open for this tx -> close and unselect
          sheet.style.display = 'none';
          currentOpenTx = null;
          setSelected(tx, false);
        } else {
          // opening sheet for this tx -> deselect all others, select this one
          txList.forEach(t => {
            if (t.id !== tx.id) setSelected(t, false);
          });
          setSelected(tx, true);
          sheet.style.display = 'block';
          openSheet(tx);
        }
      });

      tx.marker.on('dragend',()=>{ const ll=tx.marker.getLatLng(); tx.crs=map.options.crs.project(ll); if(tx.line) drawTrail(tx); updateCoverageForTX(tx); repositionTipIfNeeded(tx); });
      tx.marker.on('drag', ()=> repositionTipIfNeeded(tx));
      tx.marker.on('mouseover',()=>showTip(tx));
      tx.marker.on('mouseout',hideTip);
    }

    function drawTrail(tx) {
      if(!rx) return;
      if(tx.line) try { map.removeLayer(tx.line); } catch (e) {}
      tx.line = L.polyline([rx.getLatLng(),tx.marker.getLatLng()],{color:'red',weight:2,opacity:0.7, pane: 'trailPane'}).addTo(map);
    }

    map.on('contextmenu',e=>{
      if(rx) return;
      rx = L.marker(e.latlng,{icon:icons.rx,draggable:true}).addTo(map);
      rx.crs = map.options.crs.project(e.latlng);
      const pt = map.latLngToLayerPoint(e.latlng);
      document.cookie = 'rx_x=' + pt.x + ';rx_y=' + pt.y;
      rx.on('dragend',()=>{
        const ll=rx.getLatLng(); rx.crs=map.options.crs.project(ll);
        txList.forEach(t=> t.line && drawTrail(t));
      });
    });

    const sheet=document.getElementById('tx-sheet');

    function openSheet(tx){
      currentOpenTx = tx.id;
      sheet.innerHTML = '';
      const h = document.createElement('h4'); h.textContent = tx.name; sheet.appendChild(h);

      const table = document.createElement('table');
      const hdr = table.insertRow();
      ['Freq','Name','PI','kW',''].forEach(t => { const th = document.createElement('th'); th.innerText = t; hdr.appendChild(th); });

      let crit = tx.highlightCriteria || null;
      if (!crit) {
        if (filterStationName) crit = { type: 'name', value: filterStationName };
        else if (filterFreq) crit = { type: 'freq', value: filterFreq };
        else if (filterPI) crit = { type: 'pi', value: filterPI };
        else if (filterEIRP) crit = { type: 'eirp', value: filterEIRP };
        else if (filterFreq || filterPI || filterEIRP) crit = { type: 'global', value: null };
      }

      tx.stations.forEach((s, i) => {
        const r = table.insertRow();
        let isMatch = true;
        if (crit) {
          if (crit.type === 'freq') {
            isMatch = Number(s.freq) === Number(crit.value);
          } else if (crit.type === 'pi') {
            isMatch = (s.pi && String(s.pi).toUpperCase() === String(crit.value).toUpperCase());
          } else if (crit.type === 'eirp') {
            isMatch = (Number(s.kw) || 0) >= Number(crit.value);
          } else if (crit.type === 'name') {
            isMatch = (s.name && String(s.name).trim().toUpperCase() === String(crit.value).toUpperCase());
          } else if (crit.type === 'global') {
            const freqMatch = !filterFreq || Number(s.freq) === Number(filterFreq);
            const piMatch = !filterPI || (s.pi && String(s.pi).toUpperCase() === String(filterPI).toUpperCase());
            const eirpMatch = !filterEIRP || (Number(s.kw) || 0) >= filterEIRP;
            isMatch = freqMatch && piMatch && eirpMatch;
          } else {
            isMatch = true;
          }
        }

        if (crit && isMatch) r.classList.add('highlight'); else if (crit && !isMatch) r.classList.add('dim');

        const freqCell = r.insertCell();
        const freqBtn = document.createElement('button');
        freqBtn.className = 'freq-btn';
        const freqText = s.freq !== undefined ? String(s.freq) : '';
        const polText = (s.pol || '').toString().trim();
        freqBtn.innerHTML = '<span class="freq-val">' + freqText + '</span>' + (polText ? '<span class="pol">' + polText.charAt(0).toLowerCase() + '</span>' : '');
        freqBtn.setAttribute('aria-label', freqText + (polText ? polText.charAt(0).toLowerCase() : ''));

        if ((tx.highlightCriteria && tx.highlightCriteria.type === 'freq' && Number(tx.highlightCriteria.value) === Number(s.freq))
            || (filterFreq && Number(filterFreq) === Number(s.freq))) {
          freqBtn.classList.add('criteria');
        }

        freqBtn.onclick = () => {
          toggleCoverageForStation(tx, i, freqBtn);
          if (tx.highlightCriteria && tx.highlightCriteria.type === 'freq' && Number(tx.highlightCriteria.value) === Number(s.freq)) {
            tx.highlightCriteria = null;
          } else {
            tx.highlightCriteria = { type: 'freq', value: s.freq };
          }
          openSheet(tx);
        };
        if (tx.stationCircles[i]) freqBtn.classList.add('active');
        freqCell.appendChild(freqBtn);

        const nameCell = r.insertCell();
        nameCell.innerText = s.name || '';
        nameCell.className = 'station-name';
        nameCell.title = 'Click to filter by this station';
        nameCell.onclick = () => {
          const sval = s.name ? s.name.trim() : '';
          document.getElementById('station-filter').value = sval;
          filterStationName = sval.length ? sval.toUpperCase() : null;
          applyFilters();
        };

        const piCell = r.insertCell(); piCell.innerText = s.pi || '';
        const kwCell = r.insertCell(); kwCell.innerText = (s.kw !== undefined && s.kw !== null && !isNaN(s.kw)) ? (Number(s.kw).toFixed(3) + ' kW') : '';

        const ctlCell = r.insertCell();
        const e = document.createElement('button'); e.innerText = 'âœŽ'; e.className='small';
        e.onclick = () => { editStation(tx, i); };
        const d = document.createElement('button'); d.innerText='ðŸ—‘'; d.className='small';
        d.onclick = () => {
          if (tx.stationCircles[i]) {
            try { map.removeLayer(tx.stationCircles[i].layer); } catch(e) {}
            delete tx.stationCircles[i];
          }
          tx.stations.splice(i,1);
          openSheet(tx);
          updateIcon(tx);
        };
        ctlCell.append(e,d);
      });

      const add = document.createElement('button'); add.innerText='Add station'; add.onclick=()=>addStation(tx);
      const del = document.createElement('button'); del.innerText='Delete TX'; del.style.marginLeft='10px';
      del.onclick = () => { map.removeLayer(tx.marker); if(tx.line) map.removeLayer(tx.line); Object.values(tx.stationCircles||{}).forEach(c => { try{ map.removeLayer(c.layer); }catch{} }); txList = txList.filter(t => t.id !== tx.id); selected.delete(tx.id); sheet.style.display='none'; currentOpenTx = null; };
      sheet.append(table, add, del);
    }

    function addStation(tx){
      const f=parseFloat(prompt('Freq(65.75-108):'));
      if(isNaN(f)||f<65.75||f>108)return;
      const p=prompt('Pol(H,V,C,M,?):');
      const n=prompt('Name:');
      const pi=prompt('PI:');
      const kwInput=prompt('kW:');
      const kw=parseFloat(kwInput);

      const dirFlag = (prompt('Make this station directional? (Y/N)') || '').trim().toUpperCase();
      let directional = false, directionAngle = null;
      if (dirFlag === 'Y' || dirFlag === 'YES') {
        directional = true;
        const angleInput = prompt('Direction angle (0-359, 0 = North, clockwise):', '0');
        const angleNum = parseInt(angleInput, 10);
        if (!isNaN(angleNum) && angleNum >= 0 && angleNum <= 359) directionAngle = angleNum;
        else { directional = false; directionAngle = null; }
      }

      tx.stations.push({freq:f,pol:p,name:n,pi:pi,kw:kw, directional: directional, directionAngle: directionAngle});

      if (tx.stations && tx.stations.length) {
        tx.stations.sort((a, b) => (Number(a.freq) || 0) - (Number(b.freq) || 0));
      }

      openSheet(tx);
      updateIcon(tx);
    }

    function editStation(tx,i){
      const s=tx.stations[i];
      const f=parseFloat(prompt('Freq:',s.freq));
      if(isNaN(f)||f<65.75||f>108)return;
      s.freq=f;
      s.pol=prompt('Pol:',s.pol);
      s.name=prompt('Name:',s.name);
      s.pi=prompt('PI:',s.pi);
      const kwInput = prompt('kW:', s.kw);
      s.kw = parseFloat(kwInput);

      const dirFlag = (prompt('Make this station directional? (Y/N)', s.directional ? 'Y' : 'N') || '').trim().toUpperCase();
      if (dirFlag === 'Y' || dirFlag === 'YES') {
        s.directional = true;
        const angleInput = prompt('Direction angle (0-359, 0 = North, clockwise):', (typeof s.directionAngle === 'number' && !isNaN(s.directionAngle)) ? String(s.directionAngle) : '0');
        const angleNum = parseInt(angleInput, 10);
        if (!isNaN(angleNum) && angleNum >= 0 && angleNum <= 359) s.directionAngle = angleNum; else { s.directional = false; s.directionAngle = null; }
      } else {
        s.directional = false;
        s.directionAngle = null;
      }

      if (tx.stations && tx.stations.length) {
        tx.stations.sort((a, b) => (Number(a.freq) || 0) - (Number(b.freq) || 0));
      }

      openSheet(tx);
      updateIcon(tx);
    }

    function updateIcon(tx){
      let m = 0;
      const filteredStations = tx.stations.filter(s => {
        const freqMatch = !filterFreq || s.freq === filterFreq;
        const piMatch = !filterPI || (s.pi && s.pi.toUpperCase() === filterPI);
        const eirpMatch = !filterEIRP || (s.kw || 0) >= filterEIRP;
        const nameMatch = !filterStationName || (s.name && s.name.trim().toUpperCase() === filterStationName);
        return freqMatch && piMatch && eirpMatch && nameMatch;
      });
      if (filteredStations.length) m = Math.max(...filteredStations.map(s => s.kw || 0));
      else if (!filterFreq && !filterPI && !filterEIRP && !filterStationName && tx.stations.length) m = Math.max(...tx.stations.map(s => s.kw || 0));

      if (m >= 5) { tx.iconType = 'hi'; }
      else if (m >= 0.5) { tx.iconType = 'med'; }
      else { tx.iconType = 'lo'; }

      // ensure selection state is respected after changing iconType
      setSelected(tx, selected.has(tx.id));
    }

    const tip = document.createElement('div');
    tip.className = 'tooltip-box';
    document.body.append(tip);
    let hoveredTx = null;

    function positionTipForTx(tx) {
      if (!tx) return;
      if (!rx) return;

      const crsRx = rx.crs || map.options.crs.project(rx.getLatLng());
      const crsTx = tx.crs || map.options.crs.project(tx.marker.getLatLng());
      const dx = crsRx.x - crsTx.x, dy = crsRx.y - crsTx.y;
      const distKm = Math.sqrt(dx*dx + dy*dy) * 0.1;
      const distKmRounded = Math.round(distKm);
      const az = computeAzimuthCRS(crsTx, crsRx);

      tip.innerHTML = '';
      const nameNode = document.createTextNode(tx.name + ' â€“ ');
      const kmSpan = document.createElement('span');
      kmSpan.textContent = distKmRounded + ' km';
      if (distKmRounded >= 700) { kmSpan.style.color = 'red'; kmSpan.style.fontWeight = 'bold'; }
      else if (distKmRounded >= 400) { kmSpan.style.color = 'black'; kmSpan.style.fontWeight = 'bold'; }
      else { kmSpan.style.color = 'black'; kmSpan.style.fontWeight = 'normal'; }
      const restNode = document.createTextNode(' â€“ ' + az + 'Â°');
      tip.appendChild(nameNode);
      tip.appendChild(kmSpan);
      tip.appendChild(restNode);

      let clientX, clientY;
      const iconEl = (tx.marker && tx.marker.getElement) ? tx.marker.getElement() : null;

      if (iconEl && iconEl.getBoundingClientRect) {
        const rect = iconEl.getBoundingClientRect();
        clientX = rect.left;
        clientY = rect.top + rect.height;
      } else {
        const pos = map.latLngToContainerPoint(tx.marker.getLatLng());
        const containerRect = map.getContainer().getBoundingClientRect();
        clientX = containerRect.left + pos.x;
        clientY = containerRect.top + pos.y;
      }

      const iconType = tx.iconType || 'lo';
      const offset = tooltipOffsets[iconType] || {x:0,y:0};
      const nudge  = tooltipNudge[iconType]  || {x:0,y:0};

      tip.style.visibility = 'hidden';
      tip.style.display = 'block';
      const left = Math.round(clientX + offset.x + nudge.x);
      const top  = Math.round(clientY + offset.y + nudge.y);
      tip.style.left = left + 'px';
      tip.style.top  = top + 'px';
      tip.style.visibility = 'visible';
      tip.style.opacity = '1';
    }

    function showTip(tx) { hoveredTx = tx; if (!rx) return; positionTipForTx(tx); }
    function hideTip() { hoveredTx = null; tip.style.display = 'none'; tip.style.opacity = '0'; }
    function repositionTipIfNeeded(tx) { if (hoveredTx && tx && hoveredTx.id === tx.id) positionTipForTx(tx); }
    map.on('move zoom', () => { if (hoveredTx) positionTipForTx(hoveredTx); });

    function applyFilters() {
      txList.forEach(tx => {
        const matchesFreq = !filterFreq || tx.stations.some(s => s.freq === filterFreq);
        const matchesPI = !filterPI || tx.stations.some(s => s.pi && s.pi.toUpperCase() === filterPI);
        const matchesEIRP = !filterEIRP || tx.stations.some(s => (s.kw || 0) >= filterEIRP);
        const matchesName = !filterStationName || tx.stations.some(s => s.name && s.name.trim().toUpperCase() === filterStationName);
        const shouldShow = matchesFreq && matchesPI && matchesEIRP && matchesName;
        if (shouldShow) {
          if (!map.hasLayer(tx.marker)) map.addLayer(tx.marker);
        } else {
          if (map.hasLayer(tx.marker)) map.removeLayer(tx.marker);
        }
        updateIcon(tx);
      });

      updateSheetIfOpen();
    }

    document.getElementById('freq-filter').oninput = e => { filterFreq = parseFloat(e.target.value) || null; applyFilters(); };
    document.getElementById('pi-filter').oninput = e => { const input = e.target.value.trim().toUpperCase(); filterPI = input.length ? input : null; applyFilters(); };
    document.getElementById('eirp-filter').oninput = e => { filterEIRP = parseFloat(e.target.value) || null; applyFilters(); };
    document.getElementById('station-filter').oninput = e => { const input = e.target.value.trim().toUpperCase(); filterStationName = input.length ? input : null; applyFilters(); };

document.getElementById('toggle-selected').onclick = () => {
  showSelected = !showSelected;

  // update button label so it's obvious what's active
  const btn = document.getElementById('toggle-selected');
  btn.innerText = showSelected ? 'Show: Selected & Trailed' : 'Show All TXs';

  txList.forEach(tx => {
    // when the toggle is ON we want to show:
    //  - TXs that are explicitly selected
    //  - TXs that currently have a trail (tx.line)
    // when the toggle is OFF we show all TXs
    const shouldShow = !showSelected || selected.has(tx.id) || (tx.line != null);

    if (shouldShow) {
      if (!map.hasLayer(tx.marker)) map.addLayer(tx.marker);
    } else {
      if (map.hasLayer(tx.marker)) map.removeLayer(tx.marker);
    }
  });
};


    /********* Coverage polygon logic (seeded, directional-only rear bulge) *********/

    // seeded PRNG (mulberry32)
    function seedFromString(str) {
      let h = 2166136261 >>> 0;
      for (let i = 0; i < str.length; i++) h = Math.imul(h ^ str.charCodeAt(i), 16777619) >>> 0;
      return h;
    }
    function mulberry32(a) {
      return function() {
        a |= 0; a = (a + 0x6D2B79F5) | 0;
        let t = Math.imul(a ^ a >>> 15, 1 | a);
        t = (t + Math.imul(t ^ t >>> 7, 61 | t)) ^ t;
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      };
    }

    function degToRad(d){ return d * Math.PI/180; }

    function createCoveragePolygon(centerLatLng, radiusKm, tx, stationIndex, directional=false, directionAngle=null, segments = 64) {
      if (!radiusKm || radiusKm <= 0) return L.polygon([], { pane: 'coveragePane', color:'blue', weight:2, opacity:0.6, fillOpacity:0.08 });

      const quant = Math.round(radiusKm * 10);
      const seedStr = String(tx.id) + '_' + String(quant);
      const rnd = mulberry32(seedFromString(seedStr));

      const centerCRS = map.options.crs.project(centerLatLng);
      const latlngs = [];
      const R = radiusKm;

      let dirAngle = null;
      if (typeof directionAngle === 'number' && !isNaN(directionAngle)) {
        dirAngle = ((directionAngle % 360) + 360) % 360;
      }

      const bulgeDir = (directional === true && dirAngle !== null) ? ((dirAngle + 180) % 360) : null;

      const coneDeg = 30;
      const maxBias  = 0.40;
      const smallJitterRange = 0.06;

      for (let i = 0; i < segments; i++) {
        const a = (i / segments) * Math.PI * 2; // 0 = east, ccw positive
        const angleDeg = (90 - (a * 180 / Math.PI) + 360) % 360; // 0 = north, clockwise

        let baseRadius = R;
        let pol = null;
        try { const s = tx.stations && tx.stations[stationIndex]; if (s && s.pol) pol = String(s.pol).toUpperCase(); } catch (e) { pol = null; }

        if (directional === true) {
          if (pol === 'C' || pol === 'O') {
            baseRadius = R;
          } else if (pol === 'H') {
            const nearestVertex = Math.round(angleDeg / 45) * 45;
            let delta = Math.abs(((angleDeg - nearestVertex + 540) % 360) - 180);
            if (delta > 180) delta = 360 - delta;
            const t = 1 - Math.min(delta, 22.5) / 22.5;
            const octFactor = 0.94 + 0.12 * t;
            const localJitter = 1 + (rnd() - 0.5) * 0.06;
            baseRadius = R * octFactor * localJitter;
          } else if (pol === 'V') {
            if (dirAngle === null) {
              const delta = Math.min(Math.abs(((angleDeg - 0 + 540) % 360) - 180), 180);
              if (delta <= 90) baseRadius = R * 0.9;
              else { const theta = a; const wFactor = 1 + 0.18 * Math.cos(4 * theta); baseRadius = R * wFactor * 0.85; }
            } else {
              const delta = Math.abs(((angleDeg - dirAngle + 540) % 360) - 180);
              if (delta <= 90) baseRadius = R * 0.9;
              else { const relRad = degToRad(angleDeg - dirAngle + 90); const wFactor = 1 + 0.18 * Math.cos(4 * relRad); baseRadius = R * wFactor * 0.85; }
            }
          } else {
            baseRadius = R;
          }

          if (dirAngle !== null) {
            let delta = Math.abs(((angleDeg - dirAngle + 540) % 360) - 180);
            const t = (Math.cos(degToRad(delta)) + 1) / 2;
            const backMin = 0.2 * R;
            baseRadius = backMin + (baseRadius - backMin) * t;
          }
        } else {
          baseRadius = R;
        }

        // Default jitter: none when no polarization (pol falsy) -> perfect circle
        const defaultJitter = (!pol) ? 1 : 1 + (rnd() - 0.5) * smallJitterRange;

        let perturb;
        if (!pol) {
          // no polarization specified -> perfect circle
          perturb = 1;
        } else {
          if (directional === true && bulgeDir !== null) {
            const raw = Math.abs(((angleDeg - bulgeDir + 360) % 360));
            const angDiff = Math.min(raw, 360 - raw);

            if (angDiff <= coneDeg) {
              const frac = 1 - (angDiff / coneDeg);
              let combinedFrac = frac;
              const dblChance = 0.35;
              if (rnd() < dblChance) {
                const offset = 8 + Math.floor(rnd() * 11);
                const raw2 = Math.abs(((angleDeg - (bulgeDir + offset) + 360) % 360));
                const angDiff2 = Math.min(raw2, 360 - raw2);
                let frac2 = 0;
                if (angDiff2 <= coneDeg) frac2 = 1 - (angDiff2 / coneDeg);
                combinedFrac = Math.max(frac, frac2);
              }

              const bias = 1 + maxBias * combinedFrac;
              const localJitter = 1 + (rnd() - 0.5) * 0.08;
              perturb = bias * localJitter;
            } else {
              perturb = defaultJitter;
            }
          } else {
            perturb = defaultJitter;
          }
        }

        const r = Math.max(0.1, baseRadius * perturb);

        const dx = Math.cos(a) * r * 10;
        const dy = Math.sin(a) * r * 10;
        const ptCRS = L.point(centerCRS.x + dx, centerCRS.y + dy);
        latlngs.push(map.options.crs.unproject(ptCRS));
      }

      return L.polygon(latlngs, { pane: 'coveragePane', color: 'blue', weight: 2, opacity: 0.6, fillOpacity: 0.08 });
    }

    function kW_to_km_radius(kw) {
      const k = Number(kw) || 0;
      if (k <= 0) return 0;
      const log = Math.log10(k);
      const radius = -3 * (log * log) + 37.5 * log + 65;
      return Math.max(0, radius);
    }

    function toggleCoverageForStation(tx, stationIndex, freqBtnElement) {
      const s = tx.stations[stationIndex];
      if (!s) return;
      const kw = Number(s.kw) || 0;
      const radiusKm = kW_to_km_radius(kw);
      if (tx.stationCircles && tx.stationCircles[stationIndex]) {
        try { map.removeLayer(tx.stationCircles[stationIndex].layer); } catch (e) {}
        delete tx.stationCircles[stationIndex];
        if (freqBtnElement) freqBtnElement.classList.remove('active');
        return;
      }

      const dirFlag = isDirectionalFlag(s.directional);
      const poly = createCoveragePolygon(tx.marker.getLatLng(), radiusKm, tx, stationIndex, dirFlag, s.directionAngle);
      poly.addTo(map);
      tx.stationCircles[stationIndex] = { layer: poly, km: radiusKm, centerLatLng: tx.marker.getLatLng(), directional: dirFlag, directionAngle: s.directionAngle };
      if (freqBtnElement) freqBtnElement.classList.add('active');
    }

    function updateCoverageForTX(tx) {
      if (!tx.stationCircles) return;
      Object.keys(tx.stationCircles).forEach(idx => {
        const sc = tx.stationCircles[idx];
        if (!sc) return;
        try { map.removeLayer(sc.layer); } catch (e) {}
        const s = tx.stations[idx];
        const radiusKm = sc.km || (s ? kW_to_km_radius(s.kw) : 0);
        const dirFlag = isDirectionalFlag(s ? s.directional : false);
        const poly = createCoveragePolygon(tx.marker.getLatLng(), radiusKm, tx, idx, dirFlag, s && s.directionAngle);
        poly.addTo(map);
        tx.stationCircles[idx] = { layer: poly, km: radiusKm, centerLatLng: tx.marker.getLatLng(), directional: dirFlag, directionAngle: s && s.directionAngle };
      });
    }

    function updateAllCoverage() { txList.forEach(tx => updateCoverageForTX(tx)); }
    map.on('zoomend', updateAllCoverage); map.on('moveend', updateAllCoverage);

    function removeAllCoverage() {
      txList.forEach(tx => {
        if (!tx.stationCircles) return;
        Object.values(tx.stationCircles).forEach(c => { try{ map.removeLayer(c.layer); } catch {} });
        tx.stationCircles = {};
      });
    }

    function updateSheetIfOpen() {
      if (!currentOpenTx) return;
      const tx = txList.find(t => t.id === currentOpenTx);
      if (tx) {
        if (!tx.highlightCriteria && (filterPI || filterEIRP || filterFreq || filterStationName)) {
          tx.highlightCriteria = { type: 'global', value: null };
          const prev = tx.highlightCriteria;
          openSheet(tx);
          tx.highlightCriteria = null;
        } else {
          openSheet(tx);
        }
      } else {
        currentOpenTx = null;
        sheet.style.display = 'none';
      }
    }

    /********* End coverage logic *********/

  };
  </script>
</body>
</html>
