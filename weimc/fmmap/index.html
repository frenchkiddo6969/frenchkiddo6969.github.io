<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>weimc - FM transmitter maps</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
  <style>
    html, body { height: 100%; margin: 0; padding: 0; font-family: Arial, sans-serif; }
    #top-panel { position: absolute; top: 0; left: 0; right: 0; height: 50px; background: #333; display: flex; align-items: center; padding: 5px; z-index: 1000; }
    #top-panel button, #top-panel input { margin-right: 8px; height: 30px; font-family: Arial, sans-serif; }
    #map { position: absolute; top: 50px; bottom: 0; width: 100%; }
    #tx-sheet { position: absolute; top: 50px; left: 10px; width: 300px; background: #fff; padding: 10px; box-shadow: 0 0 5px rgba(0,0,0,0.5); z-index: 1001; display: none; max-height: 80%; overflow-y: auto; font-family: Arial, sans-serif; }
    .tooltip-box { position: absolute; pointer-events: none; background: rgba(255,255,255,0.95); padding: 5px; border: 1px solid #666; font-size: 12px; z-index: 2000; white-space: nowrap; font-family: Arial, sans-serif; transition: color 0.12s, font-weight 0.12s, opacity 0.12s; opacity: 0; box-shadow: 0 1px 4px rgba(0,0,0,0.12); border-radius: 3px; }
    table { width: 100%; border-collapse: collapse; margin-bottom: 5px; font-family: Arial, sans-serif; }
    th, td { border: 1px solid #ccc; padding: 4px; font-size: 12px; }
    button.small { padding: 2px 5px; font-size: 12px; }
    .freq-btn { background: none; border: none; text-decoration: underline; cursor: pointer; padding: 0; color: #0645ad; font-family: inherit; }
    .freq-btn.active { background: rgba(6,69,173,0.08); border-radius: 3px; }
  </style>
</head>
<body>
  <div id="top-panel">
    <button id="load-db">Load DB</button>
    <button id="save-db">Save DB</button>
    <button id="add-tx">Add TX</button>
    <input type="text" id="freq-filter" placeholder="Filter frequency (e.g. 105.7)" />
    <input type="text" id="pi-filter" placeholder="Filter PI code (e.g. 8201)" />
    <input type="text" id="eirp-filter" placeholder="Min EIRP (kW)" />
    <button id="toggle-selected">Toggle Selected TXs</button>
  </div>
  <div id="tx-sheet"></div>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
  <script>
  window.onload = function () {
    const map = L.map('map', { crs: L.CRS.Simple, minZoom: -5, maxZoom: 2, zoomSnap: 0.1 });
    const imgUrl = 'https://main-hostize-com.s3.us-west-2.amazonaws.com/1754698597_Taqeasmyxo?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIA4XIV7DNDANIP5Y7Y%2F20250809%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20250809T001707Z&X-Amz-Expires=3600&X-Amz-Signature=e4fa86a0ad6b83d178af53179dead971a7d55dc552199addcefa64c419e5551a&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject';
    const bounds = [[0,0],[15904,15968]];
    L.imageOverlay(imgUrl, bounds).addTo(map);
    map.fitBounds(bounds);

    const icons = {
      low:  L.icon({ iconUrl:'https://maps.fmdx.org/old/img/tx-lo.png', iconSize:[19,19], iconAnchor:[9.5,19] }),
      med:  L.icon({ iconUrl:'https://maps.fmdx.org/old/img/tx-med.png', iconSize:[23,23], iconAnchor:[11.5,23] }),
      high: L.icon({ iconUrl:'https://maps.fmdx.org/old/img/tx-hi.png', iconSize:[27,27], iconAnchor:[13.5,27] }),
      rx:   L.icon({ iconUrl:'https://maps.fmdx.org/old/img/rx.png',    iconSize:[34,26], iconAnchor:[17,26] })
    };

    // base offsets (where the icon's bottom-left corner is relative to the marker point)
    const tooltipOffsets = {
      lo:  { x: 6,  y: 18 },
      med: { x: 8,  y: 22 },
      hi:  { x: 9,  y: 26 }
    };

    // nudge values (hard-coded per your instruction)
    const tooltipNudge = {
      lo:  { x: 0,  y: -19 },
      med: { x: 0,  y: -23 },
      hi:  { x: 0,  y: -27 }
    };

    let txList = [], rx = null, addingTX = false, filterFreq = null, filterPI = null, filterEIRP = null, showSelected = false;
    const selected = new Set();

    function computeDistanceCRS(crs1, crs2) {
      const dx = crs2.x - crs1.x, dy = crs2.y - crs1.y;
      return (Math.sqrt(dx * dx + dy * dy) * 0.1).toFixed(1);
    }

    function computeAzimuthCRS(crs1, crs2) {
      let theta = Math.atan2(crs2.x - crs1.x, crs2.y - crs1.y) * 180 / Math.PI;
      return ((theta + 360) % 360).toFixed(0);
    }

    document.getElementById('save-db').onclick = () => {
      const saveable = txList.map(tx => ({ id: tx.id, name: tx.name, stations: tx.stations, point: tx.point, latlng: tx.latlng }));
      const blob = new Blob([JSON.stringify({txList: saveable})], {type: 'application/json'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'fm_tx_db.json';
      a.click();
    };

    async function loadDB(urlFallback) {
      try {
        const res = await fetch(urlFallback);
        const loaded = await res.json();
        loaded.txList.forEach(t => { if (t.point) createTX(t, true); });
      } catch {
        const inp = document.createElement('input'); inp.type='file'; inp.accept='application/json';
        inp.onchange = e => {
          const r = new FileReader();
          r.onload = () => JSON.parse(r.result).txList.forEach(t => { if (t.point) createTX(t, true); });
          r.readAsText(e.target.files[0]);
        };
        inp.click();
      }
    }

    document.getElementById('load-db').onclick = () => loadDB('https://raw.githubusercontent.com/frenchkiddo6969/weizkule.github.io/refs/heads/main/weimc/fmmap/txs.json');
    loadDB('https://raw.githubusercontent.com/frenchkiddo6969/weizkule.github.io/refs/heads/main/weimc/fmmap/txs.json');

    document.getElementById('add-tx').onclick = () => { addingTX = true; map.getContainer().style.cursor='crosshair'; };
    map.on('click', e => {
      if(!addingTX) return;
      const name = prompt('Site name:'); if(!name){addingTX=false;map.getContainer().style.cursor='';return;}
      createTX({id:Date.now(),name,stations:[],point:map.latLngToLayerPoint(e.latlng)});
      addingTX=false; map.getContainer().style.cursor='';
    });

    function createTX(data,load=false) {
      const latlng = data.latlng ? L.latLng(data.latlng[0], data.latlng[1]) : map.layerPointToLatLng(data.point);
      const crsPt = map.options.crs.project(latlng);
      const marker = L.marker(latlng,{icon:icons.low,draggable:true}).addTo(map);
      const tx = {...data, marker, line: null, crs: crsPt, latlng: [latlng.lat, latlng.lng], stationCircles: {}, iconType: 'lo' };
      txList.push(tx); updateIcon(tx); attach(tx);
      if(load) marker.fire('add');
    }

    function attach(tx) {
      tx.marker.on('contextmenu', () => {
        if (tx.line) {
          map.removeLayer(tx.line);
          tx.line = null;
          selected.delete(tx.id);
        } else {
          drawTrail(tx);
          selected.add(tx.id);
        }
      });
      tx.marker.on('click', () => {
        sheet.style.display = sheet.style.display === 'block' ? 'none' : 'block';
        openSheet(tx);
      });
      tx.marker.on('dragend',()=>{ const ll=tx.marker.getLatLng(); tx.crs=map.options.crs.project(ll); if(tx.line) drawTrail(tx); updateCoverageForTX(tx); repositionTipIfNeeded(tx); });
      tx.marker.on('drag', ()=> repositionTipIfNeeded(tx));
      tx.marker.on('mouseover',()=>showTip(tx));
      tx.marker.on('mouseout',hideTip);
    }

    function drawTrail(tx) {
      if(!rx) return;
      if(tx.line) map.removeLayer(tx.line);
      tx.line = L.polyline([rx.getLatLng(),tx.marker.getLatLng()],{color:'red',weight:2,opacity:0.7}).addTo(map);
    }

    map.on('contextmenu',e=>{
      if(rx) return;
      rx = L.marker(e.latlng,{icon:icons.rx,draggable:true}).addTo(map);
      rx.crs = map.options.crs.project(e.latlng);
      const pt = map.latLngToLayerPoint(e.latlng);
      document.cookie = `rx_x=${pt.x};rx_y=${pt.y}`;
      rx.on('dragend',()=>{
        const ll=rx.getLatLng(); rx.crs=map.options.crs.project(ll);
        txList.forEach(t=> t.line && drawTrail(t));
      });
    });

    const sheet=document.getElementById('tx-sheet');

    function openSheet(tx){
      sheet.innerHTML = '';
      const h = document.createElement('h4'); h.textContent = tx.name; sheet.appendChild(h);

      const table = document.createElement('table');
      const hdr = table.insertRow();
      ['Freq','Pol','Name','PI','kW',''].forEach(t => { const th = document.createElement('th'); th.innerText = t; hdr.appendChild(th); });

      tx.stations.forEach((s, i) => {
        const r = table.insertRow();
        // Frequency clickable cell
        const freqCell = r.insertCell();
        const freqBtn = document.createElement('button');
        freqBtn.className = 'freq-btn';
        freqBtn.innerText = s.freq !== undefined ? String(s.freq) : '';
        // toggle coverage on click
        freqBtn.onclick = () => {
          toggleCoverageForStation(tx, i, freqBtn);
        };
        // mark active if already present
        if (tx.stationCircles[i]) freqBtn.classList.add('active');
        freqCell.appendChild(freqBtn);

        const polCell = r.insertCell(); polCell.innerText = s.pol || '';
        const nameCell = r.insertCell(); nameCell.innerText = s.name || '';
        const piCell = r.insertCell(); piCell.innerText = s.pi || '';
        const kwCell = r.insertCell(); kwCell.innerText = (s.kw !== undefined && s.kw !== null && !isNaN(s.kw)) ? (Number(s.kw).toFixed(3) + ' kW') : '';

        const ctlCell = r.insertCell();
        const e = document.createElement('button'); e.innerText = 'âœŽ'; e.className='small';
        e.onclick = () => { editStation(tx, i); };
        const d = document.createElement('button'); d.innerText='ðŸ—‘'; d.className='small';
        d.onclick = () => {
          // remove any coverage circle for this station if exists
          if (tx.stationCircles[i]) {
            try { map.removeLayer(tx.stationCircles[i].layer); } catch(e) {}
            delete tx.stationCircles[i];
          }
          tx.stations.splice(i,1);
          openSheet(tx);
          updateIcon(tx);
        };
        ctlCell.append(e,d);
      });

      const add = document.createElement('button'); add.innerText='Add station'; add.onclick=()=>addStation(tx);
      const del = document.createElement('button'); del.innerText='Delete TX'; del.style.marginLeft='10px';
      del.onclick = () => { map.removeLayer(tx.marker); if(tx.line) map.removeLayer(tx.line); // remove coverage circles
        Object.values(tx.stationCircles||{}).forEach(c => { try{ map.removeLayer(c.layer); }catch{} }); txList = txList.filter(t => t.id !== tx.id); sheet.style.display='none'; };
      sheet.append(table, add, del);
    }

    function addStation(tx){ const f=parseFloat(prompt('Freq(87.5-108):')); if(isNaN(f)||f<87.5||f>108)return; const p=prompt('Pol(H,V,C,M,?):'); const n=prompt('Name:'); const pi=prompt('PI:'); const kwInput=prompt('kW:'); const kw=parseFloat(kwInput); tx.stations.push({freq:f,pol:p,name:n,pi:pi,kw:kw});openSheet(tx);updateIcon(tx);}    
    function editStation(tx,i){ const s=tx.stations[i]; const f=parseFloat(prompt('Freq:',s.freq)); if(isNaN(f)||f<87.5||f>108)return; s.freq=f; s.pol=prompt('Pol:',s.pol); s.name=prompt('Name:',s.name); s.pi=prompt('PI:',s.pi); const kwInput = prompt('kW:', s.kw); s.kw = parseFloat(kwInput); openSheet(tx);updateIcon(tx);}  

    function updateIcon(tx){
      let m = 0;
      const filteredStations = tx.stations.filter(s => {
        const freqMatch = !filterFreq || s.freq === filterFreq;
        const piMatch = !filterPI || (s.pi && s.pi.toUpperCase() === filterPI);
        const eirpMatch = !filterEIRP || (s.kw || 0) >= filterEIRP;
        return freqMatch && piMatch && eirpMatch;
      });
      if (filteredStations.length) m = Math.max(...filteredStations.map(s => s.kw || 0));
      else if (!filterFreq && !filterPI && !filterEIRP && tx.stations.length) m = Math.max(...tx.stations.map(s => s.kw || 0));

      if (m >= 5) { tx.marker.setIcon(icons.high); tx.iconType = 'hi'; }
      else if (m >= 0.5) { tx.marker.setIcon(icons.med); tx.iconType = 'med'; }
      else { tx.marker.setIcon(icons.low); tx.iconType = 'lo'; }
    }

    // create tooltip element (hidden by default)
    const tip = document.createElement('div');
    tip.className = 'tooltip-box';
    document.body.append(tip);
    let hoveredTx = null;

    // Position the tooltip so its TOP-LEFT corner aligns with marker bottom-left (uses marker.getElement())
    function positionTipForTx(tx) {
      if (!tx) return;
      if (!rx) return;

      // Build content
      const crs1 = rx.crs || map.options.crs.project(rx.getLatLng());
      const crs2 = tx.crs || map.options.crs.project(tx.marker.getLatLng());
      const dx = crs2.x - crs1.x, dy = crs2.y - crs1.y;
      const distKm = Math.sqrt(dx*dx + dy*dy) * 0.1;
      const distKmRounded = Math.round(distKm);
      const az = computeAzimuthCRS(crs1, crs2);

      tip.innerHTML = '';
      const nameNode = document.createTextNode(tx.name + ' â€“ ');
      const kmSpan = document.createElement('span');
      kmSpan.textContent = distKmRounded + ' km';
      if (distKmRounded >= 700) {
        kmSpan.style.color = 'red';
        kmSpan.style.fontWeight = 'bold';
      } else if (distKmRounded >= 400) {
        kmSpan.style.color = 'black';
        kmSpan.style.fontWeight = 'bold';
      } else {
        kmSpan.style.color = 'black';
        kmSpan.style.fontWeight = 'normal';
      }
      const restNode = document.createTextNode(' â€“ ' + az + 'Â°');
      tip.appendChild(nameNode);
      tip.appendChild(kmSpan);
      tip.appendChild(restNode);

      // Use the marker DOM element if available (most accurate)
      let clientX, clientY;
      const iconEl = (tx.marker && tx.marker.getElement) ? tx.marker.getElement() : null;

      if (iconEl && iconEl.getBoundingClientRect) {
        const rect = iconEl.getBoundingClientRect();
        // bottom-left corner of the icon (client coords)
        clientX = rect.left;
        clientY = rect.top + rect.height;
      } else {
        // fallback: container point -> client coords
        const pos = map.latLngToContainerPoint(tx.marker.getLatLng());
        const containerRect = map.getContainer().getBoundingClientRect();
        clientX = containerRect.left + pos.x;
        clientY = containerRect.top + pos.y;
      }

      // pick offset by icon type (base offset) + nudge
      const iconType = tx.iconType || 'lo';
      const offset = tooltipOffsets[iconType] || {x:0,y:0};
      const nudge  = tooltipNudge[iconType]  || {x:0,y:0};

      // TOP-LEFT of tooltip should sit at (clientX + offset.x + nudge.x, clientY + offset.y + nudge.y)
      tip.style.visibility = 'hidden';
      tip.style.display = 'block';
      const left = Math.round(clientX + offset.x + nudge.x);
      const top  = Math.round(clientY + offset.y + nudge.y);
      tip.style.left = left + 'px';
      tip.style.top  = top + 'px';
      tip.style.visibility = 'visible';
      tip.style.opacity = '1';
    }

    function showTip(tx) {
      hoveredTx = tx;
      if (!rx) return;
      positionTipForTx(tx);
    }

    function hideTip() {
      hoveredTx = null;
      tip.style.display = 'none';
      tip.style.opacity = '0';
    }

    function repositionTipIfNeeded(tx) {
      if (hoveredTx && tx && hoveredTx.id === tx.id) positionTipForTx(tx);
    }

    // on map move/zoom reposition tooltip if needed
    map.on('move zoom', () => { if (hoveredTx) positionTipForTx(hoveredTx); });

    function applyFilters() {
      txList.forEach(tx => {
        const matchesFreq = !filterFreq || tx.stations.some(s => s.freq === filterFreq);
        const matchesPI = !filterPI || tx.stations.some(s => s.pi && s.pi.toUpperCase() === filterPI);
        const matchesEIRP = !filterEIRP || tx.stations.some(s => (s.kw || 0) >= filterEIRP);
        const shouldShow = matchesFreq && matchesPI && matchesEIRP;
        if (shouldShow) {
          if (!map.hasLayer(tx.marker)) map.addLayer(tx.marker);
        } else {
          if (map.hasLayer(tx.marker)) map.removeLayer(tx.marker);
        }
        updateIcon(tx);
      });
    }

    document.getElementById('freq-filter').oninput = e => {
      filterFreq = parseFloat(e.target.value) || null;
      applyFilters();
    };

    document.getElementById('pi-filter').oninput = e => {
      const input = e.target.value.trim().toUpperCase();
      filterPI = input.length ? input : null;
      applyFilters();
    };

    document.getElementById('eirp-filter').oninput = e => {
      filterEIRP = parseFloat(e.target.value) || null;
      applyFilters();
    };

    document.getElementById('toggle-selected').onclick=()=>{ showSelected=!showSelected; txList.forEach(tx=>{ if(showSelected&&!selected.has(tx.id))map.removeLayer(tx.marker); else if(!map.hasLayer(tx.marker))map.addLayer(tx.marker); }); };

    /********* Coverage circle logic (CRS-based) with custom radius formula *********/

    function createCoveragePolygon(centerLatLng, radiusKm, segments = 64) {
      const centerCRS = map.options.crs.project(centerLatLng);
      const radiusCRS = radiusKm * 10;
      const latlngs = [];
      for (let i = 0; i < segments; i++) {
        const a = (i / segments) * Math.PI * 2;
        const dx = Math.cos(a) * radiusCRS;
        const dy = Math.sin(a) * radiusCRS;
        const ptCRS = L.point(centerCRS.x + dx, centerCRS.y + dy);
        latlngs.push(map.options.crs.unproject(ptCRS));
      }
      return L.polygon(latlngs, { color: 'blue', weight: 2, opacity: 0.6, fillOpacity: 0.08 });
    }

    function kW_to_km_radius(kw) {
      const k = Number(kw) || 0;
      if (k <= 0) return 0;
      const log = Math.log10(k);
      const radius = -2.5 * (log * log) + 37.5 * log + 65;
      return Math.max(0, radius);
    }

    function toggleCoverageForStation(tx, stationIndex, freqBtnElement) {
      const s = tx.stations[stationIndex];
      if (!s) return;
      const kw = Number(s.kw) || 0;
      const radiusKm = kW_to_km_radius(kw);
      if (tx.stationCircles && tx.stationCircles[stationIndex]) {
        try { map.removeLayer(tx.stationCircles[stationIndex].layer); } catch (e) {}
        delete tx.stationCircles[stationIndex];
        if (freqBtnElement) freqBtnElement.classList.remove('active');
        return;
      }
      const poly = createCoveragePolygon(tx.marker.getLatLng(), radiusKm);
      poly.addTo(map);
      tx.stationCircles[stationIndex] = { layer: poly, km: radiusKm, centerLatLng: tx.marker.getLatLng() };
      if (freqBtnElement) freqBtnElement.classList.add('active');
    }

    function updateCoverageForTX(tx) {
      if (!tx.stationCircles) return;
      Object.keys(tx.stationCircles).forEach(idx => {
        const sc = tx.stationCircles[idx];
        if (!sc) return;
        try { map.removeLayer(sc.layer); } catch (e) {}
        const newPoly = createCoveragePolygon(tx.marker.getLatLng(), sc.km);
        newPoly.addTo(map);
        tx.stationCircles[idx] = { layer: newPoly, km: sc.km, centerLatLng: tx.marker.getLatLng() };
      });
    }

    function updateAllCoverage() {
      txList.forEach(tx => updateCoverageForTX(tx));
    }

    map.on('zoomend', updateAllCoverage);
    map.on('moveend', updateAllCoverage);

    function removeAllCoverage() {
      txList.forEach(tx => {
        if (!tx.stationCircles) return;
        Object.values(tx.stationCircles).forEach(c => { try{ map.removeLayer(c.layer); } catch {} });
        tx.stationCircles = {};
      });
    }

    /********* End coverage logic *********/

  };
  </script>
</body>
</html>
